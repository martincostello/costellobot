// Copyright (c) Martin Costello, 2022. All rights reserved.
// Licensed under the Apache 2.0 license. See the LICENSE file in the project root for full license information.

using System.Text;
using Microsoft.Extensions.Options;
using Octokit;
using Octokit.GraphQL;
using Octokit.GraphQL.Model;
using Octokit.Webhooks;
using Octokit.Webhooks.Events;
using Octokit.Webhooks.Events.PullRequest;
using IConnection = Octokit.GraphQL.IConnection;
using PullRequestMergeMethod = Octokit.GraphQL.Model.PullRequestMergeMethod;

namespace MartinCostello.Costellobot.Handlers;

public sealed partial class PullRequestHandler(
    IGitHubClientForInstallation client,
    IConnection connection,
    GitCommitAnalyzer commitAnalyzer,
    IOptionsMonitor<WebhookOptions> options,
    ILogger<PullRequestHandler> logger) : IHandler
{
    private readonly IOptionsMonitor<WebhookOptions> _options = options;

    public async Task HandleAsync(WebhookEvent message)
    {
        if (message is not PullRequestEvent body ||
            body.Repository is null ||
            body.PullRequest is not { } pr)
        {
            return;
        }

        bool isManualApproval = false;

        if (!IsNewPullRequestFromTrustedUser(body, out var pull))
        {
            if (!await IsManuallyApprovedAsync(pull, body))
            {
                return;
            }

            isManualApproval = true;
        }

        bool isTrusted = false;

        if (!isManualApproval)
        {
            isTrusted = await IsTrustedDependencyUpdateAsync(pull.Repository, body);
        }

        if (isManualApproval || isTrusted)
        {
            var options = _options.CurrentValue;

            if (options.Approve)
            {
                await ApproveAsync(pull);
            }

            if (options.Automerge)
            {
                await EnableAutoMergeAsync(
                    pull,
                    pr.NodeId,
                    GetMergeMethod(pr.Base.Repo));
            }
        }
    }

    private static PullRequestMergeMethod GetMergeMethod(Octokit.Webhooks.Models.Repository repo)
    {
        if (repo.AllowMergeCommit == true)
        {
            return PullRequestMergeMethod.Merge;
        }
        else if (repo.AllowSquashMerge == true)
        {
            return PullRequestMergeMethod.Squash;
        }
        else if (repo.AllowRebaseMerge == true)
        {
            return PullRequestMergeMethod.Rebase;
        }
        else
        {
            return PullRequestMergeMethod.Merge;
        }
    }

    private async Task ApproveAsync(IssueId pull)
    {
        var body = new StringBuilder(_options.CurrentValue.ApproveComment);

        if (body.Length > 0)
        {
            body.Append('\n')
                .Append('\n')
                .Append("<!-- Generated by version ")
                .Append(GitMetadata.Version)
                .Append(" of Costellobot -->");
        }

        await client.PullRequest.Review.Create(
            pull.Owner,
            pull.Name,
            pull.Number,
            new()
            {
                Body = body.ToString(),
                Event = Octokit.PullRequestReviewEvent.Approve,
            });

        Log.PullRequestApproved(logger, pull);
    }

    private async Task EnableAutoMergeAsync(
        IssueId pull,
        string nodeId,
        PullRequestMergeMethod mergeMethod)
    {
        var input = new EnablePullRequestAutoMergeInput()
        {
            MergeMethod = mergeMethod,
            PullRequestId = new(nodeId),
        };

        var mutation = new Mutation()
            .EnablePullRequestAutoMerge(input)
            .Select((p) => new { p.PullRequest.Number })
            .Compile();

        try
        {
            await connection.Run(mutation);
            Log.AutoMergeEnabled(logger, pull);
        }
        catch (Octokit.GraphQL.Core.Deserializers.ResponseDeserializerException ex) when (ex.Message.Contains("Pull request Pull request is in clean status", StringComparison.OrdinalIgnoreCase))
        {
            try
            {
                // If auto-merge failed as the PR is ready to merge, then just merge it
                var response = await client.PullRequest.Merge(pull.Owner, pull.Name, pull.Number, new()
                {
                    MergeMethod = Enum.Parse<Octokit.PullRequestMergeMethod>(mergeMethod.ToString()),
                });

                if (response.Merged)
                {
                    Log.PullRequestMerged(logger, pull);
                }
            }
            catch (Exception ex2)
            {
                Log.EnableAutoMergeFailed(logger, ex, pull, nodeId);
                Log.MergeFailed(logger, ex2, pull);
            }
        }
        catch (Exception ex)
        {
            Log.EnableAutoMergeFailed(logger, ex, pull, nodeId);
        }
    }

    private bool IsNewPullRequestFromTrustedUser(PullRequestEvent message, out IssueId pull)
    {
        pull = IssueId.Create(message.Repository!, message.PullRequest!.Number);

        if (!string.Equals(message.Action, PullRequestActionValue.Opened, StringComparison.Ordinal))
        {
            if (!string.Equals(message.Action, PullRequestActionValue.Labeled, StringComparison.Ordinal))
            {
                Log.IgnoringPullRequestAction(logger, pull, message.Action);
            }

            return false;
        }

        var options = _options.CurrentValue;

        if (options.IgnoreRepositories.Contains(pull.Repository.FullName, StringComparer.OrdinalIgnoreCase))
        {
            Log.IgnoringPullRequestAsRepositoryIgnored(logger, pull);
            return false;
        }

        if (message.PullRequest is not { } pr || pr.Draft)
        {
            Log.IgnoringPullRequestDraft(logger, pull);
            return false;
        }

        bool isTrusted = _options.CurrentValue.TrustedEntities.Users.Contains(
            pr.User.Login,
            StringComparer.Ordinal);

        if (!isTrusted)
        {
            Log.IgnoringPullRequestFromUntrustedUser(logger, pull, message.PullRequest.User.Login);
        }

        return isTrusted;
    }

    private async Task<bool> IsManuallyApprovedAsync(IssueId pull, PullRequestEvent message)
    {
        if (message is not PullRequestLabeledEvent labelled ||
            message.Sender is not { } sender ||
            message.PullRequest.State?.Value != Octokit.Webhooks.Models.PullRequestEvent.PullRequestState.Open ||
            message.PullRequest.Draft)
        {
            return false;
        }

        var comparer = StringComparer.Ordinal;
        var options = _options.CurrentValue;
        var presentLabels = message.PullRequest.Labels.Select((p) => p.Name).ToHashSet(comparer);
        var requiredLabels = options.ApproveLabels.Intersect(options.AutomergeLabels).ToHashSet(comparer);

        if (presentLabels.Count < 1 ||
            requiredLabels.Count < 1 ||
            !presentLabels.Intersect(requiredLabels).SequenceEqual(requiredLabels, comparer))
        {
            // All of the required labels are not present
            return false;
        }

        string actor = sender.Login;

        bool isCollaborator = await client.Repository.Collaborator.IsCollaborator(
            pull.Owner,
            pull.Name,
            actor);

        if (isCollaborator)
        {
            Log.PullRequestManuallyApproved(
                logger,
                pull,
                actor);
        }

        return isCollaborator;
    }

    private async Task<bool> IsTrustedDependencyUpdateAsync(RepositoryId repository, PullRequestEvent message)
    {
        var commit = await client.Repository.Commit.Get(
            repository.Owner,
            repository.Name,
            message.PullRequest.Head.Sha);

        var diff = await GetDiffAsync(message.PullRequest.DiffUrl);

        return await commitAnalyzer.IsTrustedDependencyUpdateAsync(
            repository,
            message.PullRequest.Head.Ref,
            commit,
            diff);
    }

    private async Task<string?> GetDiffAsync(string diffUrl)
    {
        try
        {
            return await client.GetDiffAsync(diffUrl);
        }
        catch (Exception ex)
        {
            Log.GetDiffFailed(logger, ex, diffUrl);
            return null;
        }
    }

    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    private static partial class Log
    {
        [LoggerMessage(
           EventId = 1,
           Level = LogLevel.Debug,
           Message = "Ignoring pull request {PullRequest} for action {Action}.")]
        public static partial void IgnoringPullRequestAction(
            ILogger logger,
            IssueId pullRequest,
            string? action);

        [LoggerMessage(
           EventId = 2,
           Level = LogLevel.Debug,
           Message = "Ignoring pull request {PullRequest} as it is a draft.")]
        public static partial void IgnoringPullRequestDraft(
            ILogger logger,
            IssueId pullRequest);

        [LoggerMessage(
           EventId = 3,
           Level = LogLevel.Debug,
           Message = "Ignoring pull request {PullRequest} from {Login} as it is not from a trusted user.")]
        public static partial void IgnoringPullRequestFromUntrustedUser(
            ILogger logger,
            IssueId pullRequest,
            string? login);

        [LoggerMessage(
           EventId = 4,
           Level = LogLevel.Information,
           Message = "Approved pull request {PullRequest}.")]
        public static partial void PullRequestApproved(
            ILogger logger,
            IssueId pullRequest);

        [LoggerMessage(
           EventId = 5,
           Level = LogLevel.Information,
           Message = "Enabled auto-merge for pull request {PullRequest}.")]
        public static partial void AutoMergeEnabled(
            ILogger logger,
            IssueId pullRequest);

        [LoggerMessage(
           EventId = 6,
           Level = LogLevel.Warning,
           Message = "Failed to enable auto-merge for pull request {PullRequest} with node ID {NodeId}.")]
        public static partial void EnableAutoMergeFailed(
            ILogger logger,
            Exception exception,
            IssueId pullRequest,
            string nodeId);

        [LoggerMessage(
           EventId = 7,
           Level = LogLevel.Debug,
           Message = "Ignoring pull request {PullRequest} as the repository is configured to be ignored.")]
        public static partial void IgnoringPullRequestAsRepositoryIgnored(
            ILogger logger,
            IssueId pullRequest);

        [LoggerMessage(
           EventId = 8,
           Level = LogLevel.Information,
           Message = "Pull request {PullRequest} was manually approved by {Actor}.")]
        public static partial void PullRequestManuallyApproved(
            ILogger logger,
            IssueId pullRequest,
            string actor);

        [LoggerMessage(
           EventId = 9,
           Level = LogLevel.Information,
           Message = "Pull request {PullRequest} merged.")]
        public static partial void PullRequestMerged(
            ILogger logger,
            IssueId pullRequest);

        [LoggerMessage(
           EventId = 10,
           Level = LogLevel.Warning,
           Message = "Failed to merge pull request {PullRequest}.")]
        public static partial void MergeFailed(
            ILogger logger,
            Exception exception,
            IssueId pullRequest);

        [LoggerMessage(
           EventId = 11,
           Level = LogLevel.Warning,
           Message = "Failed to get Git diff from URL {GitDiffUrl}.")]
        public static partial void GetDiffFailed(
            ILogger logger,
            Exception exception,
            string gitDiffUrl);
    }
}
